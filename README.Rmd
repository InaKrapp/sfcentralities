---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# sfcentralities

<!-- badges: start -->
<!-- badges: end -->

sfcentralities allows to find central points of sf objects easily. It offers two different functions to find central points:

st_geo_median is a vectorized algorithm to find the geometric median of a given set of points. The geometric median is the point at which the sum of euclidean distances to the other points are minimized.

st_closeness_centrality determines closeness centrality of points within a street network. Distances are calculated along the network, and points have a higher closeness within the network the lower their distance to all other points is.

## Installation

You can install the development version of sfcentralities from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("InaKrapp/sfcentralities")
```

## Examples

## st_geo_median
sffunctions offers the function st_geo_median to calculate geometric medians from datasets with simple features.

The geometric median for a set of points is defined as the point which minimizes the straight-line-distances to all these points. This package uses the same underlying algorithm as the 'pracma' package to calculate it, but the function is vectorized for faster computation. Furthermore, it is designed to use sf objects as input.
```{r}
# Load necessary packages
library(sf)
library(sfcentralities)

# Create example data
pts <- st_sfc(st_point(c(0, 0)), st_point(c(1, 1)), st_point(c(2, 2.2)), st_point(c(-2, 3)))
pts <- st_as_sf(pts)
st_crs(pts) <- "EPSG:3857"

# Calculate the geometric median of the dataset
single_geometric_median <- st_geo_median(pts)
```

A geometric median can be calculated for an entire dataset, or for subgroups within a dataset. To calculate medians for subgroups, the column which defines the groups has to be given as second argument to the function:

```{r}
# Create an index that is 1 for the first three points and 2 for the fourth point:
pts$index <- 1
pts[4, ]$index <- 2

# Calculate the geometric medians for each index value separately
geometric_medians_by_group <- st_geo_median(pts, "index")
```
The returned object is a sf object which contains the geometric median as geometry column as well as further information like a column 'number_of_points', the user can check how many points were used to calculate the respective median, and 'distance', which contains the sum of euclidean distances between the points and the geometric median.

Since the result is a sf object, it can be plotted easily with ggplot2:

```{r}
## Plot the results:
library(ggplot2)

ggplot() +
  geom_sf(data = pts, color = "blue", size = 5) +
  geom_sf(data = geometric_medians_by_group, color = "yellow") +
  geom_sf(data = single_geometric_median, color = "red") +
  theme_minimal()
```

Note that there are two groups in the example data: One only contains the point in the upper right, which is therefore also returned as the geometric median of that group.
The second group contains the three points in the lower right. The geometric median is the same as the middle point of them.
Calculating the geometric median of all points, the point in the upper left slightly draws it to the upper left, but the points in the lower right corner are 'dominating', so it is still very close to them.

For instances where the dataset or a subgroup of the dataset has a very low number of points, the geometric median is not defined unambiguously. In such cases, the function will act as follows:
1. If asked to calculate the geometric median from a single point, it will return the point it was given.
2. If asked to calculate the geometric median from two points, it will return the point halfway between them.

## st_closeness_centrality
Within a street network, some points can also be considered more central than others. But unlike on a plane with straight-line distances, there is no unique definition of centrality within a network.

This package implements the closeness centrality, which is defined as the inverse of the sum of the distances between a certain point in a network and all other points. In other words, the longer it would take to travel from a point to all other points, the lower is the centrality of this point.

This package is build on the dodgr-package, which offers highly optimized distance calculations along graphs. It is closely integrated with Openstreetmap, To calculate the closeness centrality for all points within a street network, the following commands can be used:

```{r}
library(dodgr)

# Use the hampi streetnet as example:
graph <- weight_streetnet(dodgr::hampi, wt_profile = "foot")

# Calculate closeness:
result <- st_closeness_centrality(graph)

# Depict results:
ggplot() +
  geom_sf(data = result, aes(color = closeness))
```

Alternatively, you can supply a placename and a mode of transport to the 'st_closeness_centrality'-function. The function will then try to download the corresponding streetnet from OpenStreetMap.
```{r, eval=F, echo=T}
# Calculate closeness:
result <- st_closeness_centrality(placename = "hampi", transport_mode = "foot")

# Depict results:
ggplot() +
  geom_sf(data = result, aes(color = closeness))
```

Instead of finding a central point within a street network, one may also wish to calculate closeness values for a certain number of points within a city. In this case, the points for which closeness centrality should be calculated can be supplied to the function as sf object:

```{r}
# Find centrality values for specific points, providing a pre-built graph
# Use the hampi streetnet as example:
graph <- weight_streetnet(dodgr::hampi, wt_profile = "foot")

# Create three example points:
pts <- sf::st_sfc(sf::st_point(c(76.42341, 15.31717)), sf::st_point(c(76.46117, 15.33059)), sf::st_point(c(76.47491, 15.34167)))
pts <- sf::st_as_sf(pts)
sf::st_crs(pts) <- "EPSG:4326"

# Calculate closeness centrality:
pts_centrality_with_graph <- st_closeness_centrality(pts, graph = graph)

# Depict results:
ggplot() +
  geom_sf(data = dodgr::hampi, color = "white") +
  geom_sf(data = pts_centrality_with_graph, aes(color = closeness))
```

Calculating the closeness centrality for a large number of points at once can be computationally demanding. If the street network is larger than a certain size or the number of points for which the closeness should be calculated is very large, computations are therefore split up in batches. They will take longer to be completed, but it allows such calculations also for large networks because the data is not stored in memory at once.

By default, batched processing is used if the closeness centrality for more than 10000 points is calculated. This can be changed with the parameter 'batched_if'.

```{r}
# Use the hampi streetnet as example:
graph <- weight_streetnet(dodgr::hampi, wt_profile = "foot")

# Calculate closeness: Use batched calculation even for small graphs.
result <- st_closeness_centrality(graph, batched_if = 50)

# Depict results:
ggplot() +
  geom_sf(data = result, aes(color = closeness))
```


